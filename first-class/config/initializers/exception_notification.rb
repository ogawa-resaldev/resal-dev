require 'exception_notification/rails'


# rakeタスクの通知
if defined?(Rake) && Rake.respond_to?(:application)
  Rake::Task.class_eval do
    alias_method :orig_execute, :execute

    def execute(args=nil)
      orig_execute(args)
    rescue => e
      ExceptionNotifier.notify_exception(e, data: { task: name })
      raise e
    end
  end
end

module ExceptionNotifier
  class LineNotifier < BaseNotifier
    def initialize(options)
      @target_id = options[:target_id]
    end

    def call(exception, options={})
      unless ignoreList().include?(exception.message.to_s) then
        message = "エラーが発生しました！\r\n"
        message += "ご確認をお願いいたします。\r\n\r\n"
        message += "【発生日時】\r\n"
        message += Time.current.strftime("%Y/%m/%d %H:%M:%S") + "\r\n\r\n"
        message += "【発生エラー】\r\n"
        message += exception.class.to_s + "\r\n\r\n"
        message += "【エラーメッセージ】\r\n"
        message += "cron.logを確認してください。\r\n" + options[:data][:task] + "\r\n" if options[:data]
        message += exception.message.to_s
        sendLine(@target_id, message)
      end
    end

    def sendLine(target_id, message)
      require 'uri'
      require 'net/http'
      require 'json'

      # チャネルアクセストークンを設定。
      token_api = ENV["LINE_TOKEN_API"]
      client_id = ENV["LINE_ERROR_LOG_CLIENT_ID"]
      client_secret = ENV["LINE_ERROR_LOG_CLIENT_SECRET"]
      headers = {
        "Content-Type": "application/x-www-form-urlencoded"
      }
      payload_for_token = {
        grant_type: "client_credentials",
        client_id: client_id,
        client_secret: client_secret
      }
      uri_for_token = URI.parse(token_api)
      access_token = JSON.parse(Net::HTTP.post_form(uri_for_token, payload_for_token).body)["access_token"]

      # メッセージを送信。
      push_api = ENV["LINE_PUSH_API"]
      push_target_id = target_id
      payload = {
        "to":push_target_id,
        "messages":[{type: "text",text: message}]
      }
      headers = {
        "Authorization": "Bearer " + access_token,
        "Content-Type":"application/json"
      }
      uri = URI.parse(push_api)
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = uri.scheme === "https"
      response = http.post(uri.path, payload.to_json, headers)
    end

    def ignoreList()
      return [
        "Can't verify CSRF token authenticity"
      ]
    end
  end
end

ExceptionNotification.configure do |config|
  # Ignore additional exception types.
  # ActiveRecord::RecordNotFound, Mongoid::Errors::DocumentNotFound, AbstractController::ActionNotFound and ActionController::RoutingError are already added.
  # config.ignored_exceptions += %w{ActionView::TemplateError CustomError}

  # Adds a condition to decide when an exception must be ignored or not.
  # The ignore_if method can be invoked multiple times to add extra conditions.
  # config.ignore_if do |exception, options|
  #   not Rails.env.production?
  # end

  # Ignore exceptions generated by crawlers
  # config.ignore_crawlers %w{Googlebot bingbot}

  # Notifiers =================================================================

  # Email notifier sends notifications by email.
  # config.add_notifier :email, {
  #   email_prefix: '[ERROR] ',
  #   sender_address: %{"Notifier" <notifier@example.com>},
  #   exception_recipients: %w{exceptions@example.com}
  # }

  # Campfire notifier sends notifications to your Campfire room. Requires 'tinder' gem.
  # config.add_notifier :campfire, {
  #   subdomain: 'my_subdomain',
  #   token: 'my_token',
  #   room_name: 'my_room'
  # }

  # HipChat notifier sends notifications to your HipChat room. Requires 'hipchat' gem.
  # config.add_notifier :hipchat, {
  #   api_token: 'my_token',
  #   room_name: 'my_room'
  # }

  # Webhook notifier sends notifications over HTTP protocol. Requires 'httparty' gem.
  # config.add_notifier :webhook, {
  #   url: 'http://example.com:5555/hubot/path',
  #   http_method: :post
  # }

  config.add_notifier :line, {
    target_id: ENV['LINE_ERROR_LOG_TARGET_ID']
  }
end
